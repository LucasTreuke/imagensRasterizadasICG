<!DOCTYPE html>
<html>
<head>
	<title> Processamento de imagens em Canvas </title>
	<script type="text/javascript" async
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async>
	</script>
</head>
<body>
	<h1>Exibição de histogramas de canais e alteração da luminância</h1>
<figure>
	<canvas id="imagemOriginal" width="900" height="600"></canvas>
	<canvas id="imagemOutput" width="900" height="600"></canvas>
	<canvas id="imagemOutputN" width="900" height="600"></canvas>
<figcaption>
		Primeira imagem: Original, segunda imagem: Processada.
	</figcaption>
</figure>


<script>

	var canvasOriginal = document.getElementById("imagemOriginal");
	var ctxOriginal = canvasOriginal.getContext("2d");

	var canvasOut = document.getElementById("imagemOutput");
	var ctxOutput = canvasOut.getContext("2d");

	var canvasOutN = document.getElementById("imagemOutputN");
	var ctxOutputN = canvasOutN.getContext("2d");

	var imgOriginal = new Image();
	var imgDataOut = new Image();

	// var imgUrl = "https://upload.wikimedia.org/wikipedia/commons/thumb/8/88/%D0%A8%D0%BF%D0%B8%D1%86%D1%96_3.jpg/1024px-%D0%A8%D0%BF%D0%B8%D1%86%D1%96_3.jpg";
	// var imgUrl = "https://upload.wikimedia.org/wikipedia/commons/thumb/c/c8/Eiffel_tower_at_Exposition_Universelle%2C_Paris%2C_1889.jpg/800px-Eiffel_tower_at_Exposition_Universelle%2C_Paris%2C_1889.jpg";

	var imgUrl = "https://images.prismic.io/mystique/42b93a56c65a3edc45e9228a1ef44035ec31c765_5e2aabb9-1560-44c5-8a92-a3ba0b2b1bd8-eiffel-tower-paris.jpg";
	
	imgOriginal.crossOrigin = '';
	imgDataOut.crossOrigin = '';
	imgOriginal.src = imgUrl;


	canvasOriginal.width = imgOriginal.width
	canvasOriginal.height = imgOriginal.height
	canvasOutN.width = imgOriginal.width
	canvasOutN.height = imgOriginal.height

	canvasOut.width = 255*3+10
	canvasOut.height = 520

	value_count = {}
	value_count["R"] = {}
	value_count["G"] = {}
	value_count["B"] = {}
	value_count["L"] = {}
	value_count["NL"] = {}


	imgOriginal.onload = function(){
		ctxOriginal.drawImage(imgOriginal, 0, 0);
		
		imgDataOut = ctxOriginal.getImageData(0, 0, imgOriginal.width, imgOriginal.height);
		imgDataHsl = {data: {}}
		
		// passa por cada pixel
		highest_value = 0
		l_highest_value = 0

		for (let i = 0; i < imgDataOut.data.length; i += 4) {
			// Faz a contagem de cada nível de cor dos canais, salva em value_count
			add_channel_count("R",imgDataOut.data[i])
			add_channel_count("G",imgDataOut.data[i+1])
			add_channel_count("B",imgDataOut.data[i+2])

			// marca o maior valor
			if (value_count["R"][imgDataOut.data[i]]>highest_value){
				highest_value=value_count["R"][imgDataOut.data[i]]
			}if (value_count["G"][imgDataOut.data[i+1]]>highest_value){
				highest_value=value_count["G"][imgDataOut.data[i+1]]
			}if (value_count["B"][imgDataOut.data[i+2]]>highest_value){
				highest_value=value_count["B"][imgDataOut.data[i+2]]
			}

			// Encontra os valores em hsl
			hsl_values = {}
			hsl = rgbToHsl(imgDataOut.data[i],imgDataOut.data[i+1],imgDataOut.data[i+2])
			hsl_values["h"] = hsl[0]
			hsl_values["s"] = hsl[1]
			hsl_values["l"] = hsl[2]

			imgDataHsl.data[i] 	   = hsl_values["h"]
			imgDataHsl.data[i + 1] = hsl_values["s"]
			imgDataHsl.data[i + 2] = hsl_values["l"]

			// Mudar luminancia
			l_multiplyer = 1.3
			old_luminance = imgDataHsl.data[i + 2]
			imgDataHsl.data[i + 2] = ((old_luminance-0.5)*l_multiplyer)+0.5

			// organiza os valores hsl para o plot, faz a contagem com o valor multiplicado por 255 (largura do plot)
			hsl_values["l"] = Math.round(hsl_values["l"]*255)
			if(value_count["L"][hsl_values["l"]]){
				value_count["L"][hsl_values["l"]]+=1
			}else{
				value_count["L"][hsl_values["l"]]=1
			}
			if(value_count["L"][hsl_values["l"]]>l_highest_value){
				l_highest_value=  value_count["L"][hsl_values["l"]]
			}

			// Faz a contagem dos valores para plotar a luminancia atualizada
			n_luminance = imgDataHsl.data[i + 2]

			n_luminance = Math.round(n_luminance*255)
			if(value_count["NL"][n_luminance]){
				value_count["NL"][n_luminance]+=1
			}else{
				value_count["NL"][n_luminance]=1
			}

			// nova imagem
			n_rgb = hslToRgb(imgDataHsl.data[i],imgDataHsl.data[i + 1],imgDataHsl.data[i + 2])
			imgDataOut.data[i] = n_rgb[0]
			imgDataOut.data[i+1] = n_rgb[1]
			imgDataOut.data[i+2] = n_rgb[2]
		
		}
		plots(value_count, highest_value)
		plot(value_count["L"], l_highest_value, 0, "#000", 1)
		plot(value_count["NL"], l_highest_value, 1, "#000", 1)
		ctxOutputN.putImageData(imgDataOut, 0, 0);
	}

	function add_channel_count(c,data){
		if (value_count[c][data]){
			value_count[c][data] += 1
		}else{
			value_count[c][data] = 1
		}
	}


	function plot(s_value_count, highest_value, offset, color, offset_y){
		offset = offset*256
		desired_height = 256
		offset_y = offset_y*(desired_height+5)
		
		s_value_count = normalize(s_value_count, highest_value, desired_height)
		for (i=0;i<256;i++){
			h=0
			if(s_value_count[i]){
				h=s_value_count[i]
			}
			ctx = ctxOutput
			ctx.strokeStyle = color
			ctx.beginPath();
			ctx.moveTo(i+offset, offset_y+desired_height);
			ctx.lineTo(i+offset, offset_y+desired_height-h);
			ctx.stroke();
		}
		ctx.strokeStyle = "#000"
		ctx.beginPath();
		ctx.rect(offset, offset_y, 255, desired_height);
		ctx.stroke();
		return s_value_count
	}

	// function special_plot(c1_dist,c2_dist){
	// 	for(i=0;i<c1_dist.length;i++){
	// 		for()
	// 	}
	// }

	function normalize(s_value_count, highest_value, desired_height){
		for(i=0;i<256;i++){
			if(s_value_count[i]){
				s_value_count[i]= Math.round(s_value_count[i]/highest_value*desired_height)
			}
		}
		return s_value_count
	}

	function plots(value_count, highest_value){
		plot(value_count["R"], highest_value, 0, "#f00", 0)
		plot(value_count["G"], highest_value, 1, "#0f0", 0)
		plot(value_count["B"], highest_value, 2, "#00f", 0)

	}

	function rgbToHsl(r, g, b) {
	r /= 255, g /= 255, b /= 255;

	var max = Math.max(r, g, b), min = Math.min(r, g, b);
	var h, s, l = (max + min) / 2;

	if (max == min) {
		h = s = 0; // achromatic
	} else {
		var d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

		switch (max) {
		case r: h = (g - b) / d + (g < b ? 6 : 0); break;
		case g: h = (b - r) / d + 2; break;
		case b: h = (r - g) / d + 4; break;
		}

		h /= 6;
	}

	return [ h, s, l ];
	}
	function hslToRgb(h, s, l) {
  var r, g, b;

  if (s == 0) {
    r = g = b = l; // achromatic
  } else {
    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    }

    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;

    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  return [ r * 255, g * 255, b * 255 ];
}
</script>

</body>
</html>